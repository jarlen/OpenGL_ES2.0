# 如何告诉OpenGL我们要画什么
在讲后面内容的时候我们需要先思考一个问题，假设让你来画一幅画的话，你需要知道哪些要素了才能开始去画这幅画呢？

Android中View的源码实现绘制的时候经历了三步，首先是测量控件的大小，因为只有知道大小了才能在布局中进行定位。其次就是确定位置，不确定位置的话就不知道要画在哪。最后才是开始绘制。

如果按照这个步骤，那么OpenGL ES2中是如何去测量，定位还有绘制的呢？

###1.OpenGL中的定位和测量
相比起Android中View，OpenGL的的定位测量要简单的多，他只需要我们在它的坐标系上 定义一些顶点，这些顶点可以有很多属性，但最重要的属性就是位置。位置属性通过x，y，z坐标来体现。通过这些顶点与顶点的组合就形成了不同的图形，而这些图形的位置也根据每个点的位置而确定了下来。

通过代码来体现就是
```
float[] tableVertices = {
                0f, 0f,0f,
                -0.5f,-0.8f,0f,
                 0.5f,-0.8f,0f,
                 0.5f,0.8f,0f,
                -0.5f,0.8f,0f,
                -0.5f,-0.8f,0f
        };
```

但这不就是一个普通的float数组么，float数组是java的类型，而OpenGL使用的是却是另外一种语言。那么我们怎么把这份数据传递给运行在本地环境的OpenGL呢？下面就会解答这个问题。

###2.如何将java数据传递给本地系统库中的OpenGL。
要知道，Android运行代码的时候并不是直接运行在硬件上的，而是运行在Dalvik虚拟机上的。运行在虚拟机上的代码不能直接访问本地环境。除非通过特定的API的接口。Android这样设计其实也是为了降低系统的耦合性，让开发者不用去关心CPU等硬件，专心搞软件就行了。这样做一般也没问题，但在与本地系统交互的时候就比较麻烦了，比如说OpenGL。OpenGL作为本地系统库直接运行在硬件上。

继续上面那个问题：如何将java数据传递给本地系统库中的OpenGL。
有两种技术可以实现：1.使用本地接口JNI技术，这个技术已经集成在Android系统android.opengl.GLES20中，我们可以直接调用.
2.改变内存分配的方式，java有一个特殊的集合，他们可以分配本地内存快，并且把java的数据复制到本地内存。而本地内存是可以被本地环境读取，这样就可以达到传递数据的目的。

代码实现如下：
```
private FloatBuffer vertexData; //缓存的顶点数据
vertexData =
                //allocateDirect分配本地内存  float数组的长度乘以每一个float类型占用的字节数
                ByteBuffer.allocateDirect(tableVertices.length * BYTES_PER_FLOAT).
                        //告诉字节缓冲区按照本地字节序组织它的内容
                        //当一个值占用多个字节，比如32位整形数，字节按照从高位到低位 或者从低位到高位排序
                        //排什么顺序其实不重要，重要的是程序运行过程中所有的字节都得按同样的顺序排序，
                        //不能有的排正序，有的排倒序。 而  order(ByteOrder.nativeOrder()就能达到这个目的。
                        order(ByteOrder.nativeOrder())
                        //根据分配的内存获取一个能分配本地内存的FloatBuffer实例对象。
                        .asFloatBuffer();
        //将顶点数据 内存从虚拟机中拷贝到本地
        vertexData.put(tableVertices);

```

现在OpenGL已经可以读取这些数据，那么它会如何去使用这些数据呢？
这就涉及到OpenGL管线的概念了。








