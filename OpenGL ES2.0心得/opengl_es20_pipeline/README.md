# OpenGL ES2.0 的管线（pipeline）
###1.OpenGL管线是什么
对于初学者而言 ，OpenGL管线 这名字一听就觉得好专业，好深奥。
但其实说白了，这只是一个比喻。就像线程池，连接池，数据库一样，用池和库来描述技术上的东西，能给人更明确的认知，让人即使不懂技术 也能大致明白这东西的用处。管线也是一样，它描述的就是一连串的任务链，每一个任务完成后输出的结果 又可以执行下一个任务，整个过程任何一步都不能调换顺序，就像一个管道或者工厂的流水线一样，所以称之为管线。

###2.管线中包括了哪些任务，又是按什么顺序执行呢？
1.设置顶点数据。这一步前面已经讲的很详细了，这里不再赘述。

2.执行顶点着色器。
绘制命令传输到每个顶点，都会执行一遍顶点着色器。
在这个着色器中，我们可以不做任何处理，只是把数值传递个下个阶段。也可以通过各种计算改变顶点的位置。比如各种变换矩阵，光照。

3.组装图元
当index数据传入之后，会根据这些数据分配顶点，并将其组合在一起，形成 点，线，三角形，之类的图元。

4.剪切
顶点如果在可视区域viewport之外，这个时候与顶点相关的图元会做出改变，以保证在视口之外的区域的像素不用绘制，这个过程叫做剪切。不过我们不用操作这个过程，它是由OpenGL自动完成的。

5.光栅化图元
首先需要理解什么是光栅化。显示屏上由成千上百万的独立组件组成，它们称之为像素。每个像素可以显示各种各样的颜色。
光栅化就是将获取到的图元信息传递到光栅化单元，生成对应的fragment片元。每一个fragment可以看成是一个候选的像素。它占的位置相当于一个像素，可以放在帧缓存中，但是它最终也可能在计算过程中被剔除，不再更新对应的像素位置。

6.执行片段着色器
通过片元着色器计算每个片元的最终颜色和深度值。如果不想绘制某个像素位置的颜色，可以调用discard 终止这个片元的处理。

7.逐片元的操作
这里使用深度测试 和模板测试决定一个片元是否可见。通过测试就可以写入帧缓存，

8.显示在屏幕上



这里我们首先需要知道 着色器（shader）究竟是个什么东东。着色器shader可以看做是你的软件和硬件GPU之间的一个信使，它会通知图形处理单元（GPU）如何绘制数据。OpenGL有很多的着色器，但是有两种着色器是必须要在运行程序之前必须要定义的。这两种着色器分别是：
<1>.顶点着色器(vertex shader) 生成每个顶点的位置，针对每个顶点它都会执行一次；一旦最终位置确定了，OpenGL就会把这些顶点的集合组装成 点，直线，以及三角形。
<2>片段着色器(fragment shader)为组成点，直线或者三角形的每个片段生成最终的颜色，针对每个片段，它都会执行一次；一个片段是一个小的，单一颜色的长方形区域，类似于计算机屏幕上的一个像素。







